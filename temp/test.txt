/* Create a dataset to hold the requirements */
data requirements;
    length requirementID $10
           SECTION $20
           PATTERNNAME $50
           PATTERN $1000
           CHECKVSOURCE $1
           CHECKCOMMENT $1
           EXAMPLE1 $200
           EXAMPLE2 $200
           EXAMPLE3 $200
           EXAMPLE4 $200
           EXAMPLE5 $200
           EXAMPLE6 $200
           EXAMPLE7 $200
           EXAMPLE8 $200
           INSTRUCTIONS $500;

    /* Requirement 1 */
    requirementID = '1';
    SECTION = 'POSTPROCESSING';
    PATTERNNAME = 'Literal post';
    PATTERN = '/^\s*(?:SET TO |EQUAL TO )?' ||
              '(?:(null)|"([^"]*?)"|(\d+)|"&([^"]+?)\.?")\.\s*$/i';
    CHECKVSOURCE = 'Y';
    CHECKCOMMENT = 'Y';
    EXAMPLE1 = 'Set to "VALUE"';               /* Removed trailing period */
    EXAMPLE2 = 'Set to "&MACROVARIABLE."';     /* Removed trailing period */
    EXAMPLE3 = 'Equal to 12345';               /* Removed trailing period */
    EXAMPLE4 = 'Set to "Another Value"';       /* Removed trailing period */
    EXAMPLE5 = 'Set to null';                  /* Removed trailing period */
    EXAMPLE6 = 'Equal to "Special!@#Chars"';   /* Removed trailing period */
    EXAMPLE7 = 'Set to "12345"';               /* Removed trailing period */
    EXAMPLE8 = 'Equal to 67890';               /* Removed trailing period */
    INSTRUCTIONS = 'Set to a null, literal string value, literal numeric value or a macro
    variable for all the records';
    output;

    /* Requirement 2 */
    requirementID = '2';
    SECTION = 'PREPROCESSING';
    PATTERNNAME = 'VariableCond_pre';
    PATTERN = '(SET TO | EQUAL TO | EQUAL TO INFORMATTED VALUE OF|' ||
              'EQUAL TO FORMATTED VALUE OF | SET TO INFORMATTED VALUE OF | ' ||
              'SET TO FORMATTED VALUE OF )?' ||
              '(Upper case )?' ||
              '(([\x30-\x39\x41-\x5A\x5F]+)\.)?' ||
              '([\x30-\x39\x41-\x5A\x5F]+\.[\x30-\x39\x41-\x5A\x5F]+)' ||
              '(when | if | when upper case of )' ||
              '(((([\x30-\x39\x41-\x5A\x5F]+)\.)?' ||
              '([\x30-\x39\x41-\x5A\x5F]+\.[\x30-\x39\x41-\x5A\x5F]+))' ||
              '(((is not Null | is Null | is numeric | is not numeric)\.?|' ||
              '((is | is not | = | contains | does not contain)' ||
              '("([\x20-\x21\x23-\x7E]*)"|[\x30-\x39]+)))' ||
              '(( or |,)("([\x20-\x21\x23-\x7E]*)"|[\x30-\x39]+))*))\.?' ||
              '(( Upper case before comparing\.)?)' ||
              '(( Upper case the variable and remove any special characters\.)?|' ||
              '( Format the value to ([\x30-\x39]+) decimals\.?)?)';
    CHECKVSOURCE = 'Y';
    CHECKCOMMENT = 'Y';
    EXAMPLE1 = 'Equal to OptionalLIBNAME.DATASET.VARIABLE when DATASET.VAR1 is "", "VALUE2" or "VALUE3"'; /* Removed trailing period */
    EXAMPLE2 = 'Equal to OptionalLIBNAME.DATASET.VARIABLE when DATASET.VAR1 is "", "VALUE2" or "VALUE3"'; /* Removed trailing period */
    /* No EXAMPLE3-8 for Requirement 2 */
    INSTRUCTIONS = 'Conditionally set to a raw variable. You can upper case character
    variables if needed and format numbers to required decimal places. The raw variable must
    be prefixed by dataset name and optionally by libname too. If libname is not specified
    then it is assumed to be RAW.';
    output;
run;



%macro generate_sas_code_with_output;
    /* Iterate over each requirement */
    proc sql noprint;
        select requirementID into :req_list separated by ' '
        from requirements;
    quit;

    %let num_reqs = %sysfunc(countw(&req_list));

    %do i=1 %to &num_reqs;
        %let req_id = %scan(&req_list, &i);

        /* Extract details for the current requirement */
        data _null_;
            set requirements;
            where requirementID = "&req_id.";
            /* Assign macro variables globally */
            call symputx('SECTION', SECTION, 'G');
            call symputx('PATTERNNAME', PATTERNNAME, 'G');
            call symputx('PATTERN', PATTERN, 'G');
            call symputx('CHECKVSOURCE', CHECKVSOURCE, 'G');
            call symputx('CHECKCOMMENT', CHECKCOMMENT, 'G');
            /* Count the number of non-missing examples */
            num_instr = 0;
            do j = 1 to 8;
                if not missing(vvaluex(cats('EXAMPLE', j))) then num_instr + 1;
            end;
            call symputx('num_instr', num_instr, 'G');
            /* Store all examples in separate macro variables */
            do j = 1 to 8;
                example = vvaluex(cats('EXAMPLE', j));
                if not missing(example) then do;
                    call symputx(cats('example', j), example, 'G');
                end;
            end;
        run;

        /* Debugging: Print the macro variables to the log */
        %put NOTE: Processing Requirement ID=&req_id.;
        %put NOTE: SECTION=&SECTION.;
        %put NOTE: PATTERNNAME=&PATTERNNAME.;
        %put NOTE: num_instr=&num_instr.;

        /* Define the output file path based on SECTION and PATTERNNAME */
        /* Replace spaces with underscores to create valid filenames */
        %let clean_section = %sysfunc(tranwrd(&SECTION, %str( ), %str(_)));
        %let clean_patternname = %sysfunc(tranwrd(&PATTERNNAME, %str( ), %str(_)));
        %let outfile = sas_autocode_&req_id._&clean_section._&clean_patternname..sas;

        /* Open the output file */
        filename out "&outfile.";

        /* Generate SAS code based on the requirement ID */
        %if &req_id. = 1 %then %do;
            /* Requirement 1: Literal post - POSTPROCESSING */

            /* Define the assignment variable */
            %let assign_var = var; /* Change as needed */

            /* Loop through each example and write to the output file */
            data _null_;
                file out;
                %do j=1 %to &num_instr;
                    /* Retrieve each example */
                    %let current_instr = &&example&j.;

                    /* Apply the regex pattern */
                    retain regex_id;
                    if _n_ = 1 then do;
                        pattern = "&PATTERN.";
                        regex_id = prxparse(pattern);
                        if missing(regex_id) then do;
                            put "ERROR: Invalid regex pattern for Requirement 1.";
                            stop;
                        end;
                    end;

                    /* Check if the instruction matches the pattern */
                    if prxmatch(regex_id, "&current_instr.") then do;
                        null_val = prxposn(regex_id, 1, "&current_instr.");
                        string_val = prxposn(regex_id, 2, "&current_instr.");
                        num_val = prxposn(regex_id, 3, "&current_instr.");
                        macro_var = prxposn(regex_id, 4, "&current_instr.");

                        if not missing(null_val) then do;
                            /* Set variable to missing */
                            code_line = cats("&assign_var.", " = .;");
                        end;
                        else if not missing(string_val) then do;
                            /* Set variable to string */
                            code_line = cats("&assign_var.", ' = "', strip(string_val), '";');
                        end;
                        else if not missing(num_val) then do;
                            /* Set variable to number */
                            code_line = cats("&assign_var.", " = ", strip(num_val), ";");
                        end;
                        else if not missing(macro_var) then do;
                            /* Set variable to macro variable */
                            code_line = cats("&assign_var.", ' = "&', strip(macro_var), '.";');
                        end;
                        else do;
                            /* Unhandled case */
                            code_line = '/* Unhandled instruction */';
                        end;

                        /* Write the code line to the output file */
                        put code_line;
                    end;
                    else do;
                        /* Instruction did not match the pattern */
                        put '/* Instruction did not match the pattern */';
                    end;
                %end;
            run;
        %end;

        %else %if &req_id. = 2 %then %do;
            /* Requirement 2: VariableCond_pre - PREPROCESSING */

            /* Define the assignment variable */
            %let assign_var = VARIABLE; /* Change as needed */

            /* Loop through each example and write to the output file */
            data _null_;
                file out;
                %do j=1 %to &num_instr;
                    /* Retrieve each example */
                    %let current_instr = &&example&j.;

                    /* Apply the regex pattern */
                    retain regex_id;
                    if _n_ = 1 then do;
                        pattern = "&PATTERN.";
                        regex_id = prxparse(pattern);
                        if missing(regex_id) then do;
                            put "ERROR: Invalid regex pattern for Requirement 2.";
                            stop;
                        end;
                    end;

                    /* Check if the instruction matches the pattern */
                    if prxmatch(regex_id, "&current_instr.") then do;
                        /* Extract capture groups */
                        libname_part = prxposn(regex_id, 3, "&current_instr.");
                        cond_var = prxposn(regex_id, 5, "&current_instr.");
                        operator = prxposn(regex_id, 7, "&current_instr.");
                        cond_values_raw = prxposn(regex_id, 8, "&current_instr.");
                        transformation1 = prxposn(regex_id, 9, "&current_instr.");
                        transformation2 = prxposn(regex_id, 10, "&current_instr.");
                        format_decimals = prxposn(regex_id, 11, "&current_instr.");

                        /* Process condition values */
                        /* Remove quotes and split by ',' or 'or' */
                        cond_values = compress(cond_values_raw, '"', 'kad'); /* Keep letters, digits */
                       cond_values = tranwrd(cond_values, ' or ', ',');
                        cond_values = tranwrd(cond_values, ',"', ',');
                        cond_values = tranwrd(cond_values, ' "', ',');
                        cond_values = strip(cond_values); /* Remove leading/trailing spaces */

                        /* Create the IN clause */
                        condition = cats(strip(cond_var), ' in ("', tranwrd(cond_values, ',', '", "'), '")');

                        /* Handle transformations */
                        transformation_clause = '';
                        if not missing(transformation1) then transformation_clause = 'upcase(';
                        if not missing(transformation2) then do;
                            if index(transformation2, 'Format the value to') then do;
                                format_num = strip(format_decimals); /* e.g., 2 */
                                transformation_clause = cats(transformation_clause, 'format(', "&assign_var.", ', 8.', strip(format_num), ')');
                            end;
                            else if index(transformation2, 'Upper case the variable') then do;
                                transformation_clause = cats(transformation_clause, 'upcase(', "&assign_var.", ')');
                            end;
                        end;
                        if transformation_clause ne '' then transformation_clause = cats(transformation_clause, ')');

                        /* Construct the raw variable */
                        if not missing(libname_part) then do;
                            raw_var = cats(strip(libname_part), '.', 'Dataset.VARIABLE');
                        end;
                        else do;
                            raw_var = cats('RAW.', 'Dataset.VARIABLE');
                        end;

                        /* Apply transformations */
                        if transformation_clause ne '' then do;
                            raw_var = cats(transformation_clause, '(', raw_var, ')');
                        end;

                        /* Apply format if required */
                        format_statement = '';
                        if not missing(format_decimals) then do;
                            format_statement = cats(' format ', "&assign_var.", ' 8.', strip(format_decimals), ';');
                        end;

                        /* Generate the SAS code line */
                        if transformation_clause ne '' and format_statement ne '' then do;
                            code_line = cats('if ', condition, ' then ', strip("&assign_var."), ' = ', raw_var, '; ', format_statement);
                        end;
                        else if transformation_clause ne '' then do;
                            code_line = cats('if ', condition, ' then ', strip("&assign_var."), ' = ', raw_var, ';');
                        end;
                        else if format_statement ne '' then do;
                            code_line = cats('if ', condition, ' then ', strip("&assign_var."), ' = ', raw_var, '; ', format_statement);
                        end;
                        else do;
                            code_line = cats('if ', condition, ' then ', strip("&assign_var."), ' = ', raw_var, ';');
                        end;

                        /* Write the code line to the output file */
                        put code_line;
                    end;
                    else do;
                        /* Instruction did not match the pattern */
                        put '/* Instruction did not match the pattern */';
                    end;
                %end;
            run;
        %end;

        %else %do;
            /* Handle additional requirements if any */
            /* For now, do nothing */
        %end;

        /* Close the output file */
        filename out clear;
    %end;
%mend generate_sas_code_with_output;

/* Execute the macro to generate and write SAS code for all requirements */
%generate_sas_code_with_output;

